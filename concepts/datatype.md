---
description: 자바스크립트에서 데이터 타입을 다루기 위한 개념을 살펴보겠습니다.
---

# 데이터 타입

![](../.gitbook/assets/datatype.png)

## 🤔 데이터 타입이란 무엇인가요?

데이터 타입은 말 그대로 **데이터의 타입**을 표현하는 역할을 합니다. 하나의 애플리케이션을 구현하기 위해서는 정말 많은 데이터가 필요할 것입니다. 이 많은 데이터들은 각각 본인의 타입을 가지게 되고, 이를 활용하여 목적에 맞는 역할을 수행하게 되는 것이죠

또한 **동적 타이핑**언어로서 변수를 할당 할 때 **타입 추론**을 하여 타입을 할당 해주기 때문에 초기화 이후 뿐만 아니라 언제든 변수가 변동된다는 특징도 가지고 있습니다. 대표적으로 유명한 파이썬 또한 같은 방식입니다.

이러한 자바스크립트에는 **7개**의 데이터 타입을 통해 타입을 관리하고 있습니다.  
하나씩 살펴보도록 하겠습니다.

## 💾 자바스크립트의 데이터 타입들

데이터 타입은 원시 타입\(primitive type\)과 객체 타입\(object type\)으로 구분되어집니다.  
두 가지는 어떤 차이가 있을까요 ?

| 구분 | 데이터 타입 | 설명 |
| :--- | :--- | :--- |
| 원시 타입 | 숫자\(number\) | 모든 숫자 타입 |
| 원시 타입 | 문자\(string\) | 문자로 된 타입 |
| 원시 타입 | 불리언\(boolean\) | 참\(true\) / 거짓\(false\) 타입 |
| 원시 타입 | undefined | var로 선언된 변수에 초기화 단계에 할당되는 타 |
| 원시 타입 | null | 값이 없는 타입 |
| 원시 타입 | symbol | 유일한 값의 타입 |
| 객체 타입 | object, function, array... | 원시 타입을 제외한 객체 타입 |

표를 보시면 객체타입은 하나로 분류가 되었고 나머지는 각각 하나의 타입을 가지고 있다는 것입니다.  
쉽게 생각한다면 객체 타입을 제외하면 나머지는 하나의 고유한 자신만의 타입을 가지고 있다는 것이죠  
  
이제 하나씩 타입들을 살펴보며 어떤 타입인지 알아보겠습니다. 

### 1. 숫자 타입

자바스크립트의 숫자는 타 프로그래밍 언어와는 다르게 **64비트 부동소수점** 방식을 따르고 있습니다. 즉, **실수**로만 표현한다는 것이죠  
  
실제로 다양한 종류의 수를 입력해도 실수로 표현됩니다.

```javascript
var integer = 10; // 정수
var double = 20.10; // 실수
var negative = -10; // 음의 정수

var binary = 0b01000001; // 2진수 65
var octal = 0o101 // 8진수 65
var hex = 0x41; // 16진수 65
```

그래서 어떠한 숫자값과 비교해도, 실수로서 비교하기 때문에 값이 동일하다면 **참**인 판단이 출력됩니다.

```javascript
console.log(binary === octal) // true
console.log(octal === hex) // true
console.log(1 === 1.0) // true
```

또한 숫자가 무한대거나, 숫자로서 연산 작업을 할 수 없을 때 사용하는 값도 존재합니다. 

* Infinity : 양수로서 값이 무한대
* -Infinity : 음수로서 값이 무한대
* NaN : 연산이 불가한 값

```javascript
console.log(10 / 0) // Infinity
console.log(10 / -0) // Infinity
console.log(10 * "hello") // NaN
```

### 2. 문자열 타입

문자열 타입은 말 그대로 **텍스트**를 타입으로 가지는 타입입니다. 작은 따옴표\(' '\), 큰 따옴표\(" "\), 백틱\(\` \`\)으로 감싼 대상으로 하여 문자열 타입을 부여합니다.

```javascript
var nickname;
nickname = 'tigger'; // 작은 따옴표
nickname = "tigger"; // 큰 따옴표
nickname = `tigger`; // 백틱

nickname = tigger // ReferenceError: tigger is not defined
```

위 세 가지 방법으로 감싸게 되면 nickname은 문자열 타입을 가지게 됩니다.  
만약 따옴표를 통해 문자열을 선언하지 않게 되면, 자바스크립트 엔진은 이걸 문자열이라고 인지하지 못하고 **식별자**로 인식하기 때문에 꼭 따옴표로 묶어주어야 합니다. 

여기서 따옴표 시리즈와는 다르게 **백틱**은 ES6 이후에 새롭게 추가된 문법으로 **템플릿 리터럴\(template literal\)**을 통해 보다 편하게 문자열을 다룰 수 있게 해줍니다. 차후 ES6 문법을 주제로 알아보도록 하겠습니다.

### 3. 불리언 타입

불리언 타입은 true 혹은 false로 구분되어진 타입입니다.  
값이 참이라면 true를, 값이 거짓이라면 false로 표현되어집니다.

```javascript
const nickname = "tigger";
console.log(nickname === "tigger") // true
console.log(nickname === "pooh") // false
```

불리언 타입은 **조건문**이나 **Flag\(깃발\)** 요소 처럼 특정 조건이 만족할 때 비즈니스 로직을 실행하는 부분에서 굉장히 많이 활용이 되는 타입입니다.

### 4. undefined

undefined는 변수에서 잠깐 등장한 개념입니다. **"자료형이 정해지지 않은 상태"**를 말하며 var로 선언된 변수에서 **초기화가 동시에 진행**되며 기본적으로 들어가 있는 값입니다. 즉, 자바스크립트 엔진이 자동으로 부여하는 값이라는 의미입니다.  
그래서 개발자들이 개발을 할 때 데이터를 할당하게 되더라도, undefined는 **할당하지 않는 것을 권장**합니다.  
  
그 이유는 자동으로 엔진에서 할당해주는 값을 직접 할당 해줄 필요도 없을 뿐더러, 어떤 의도로 할당한 것인지 파악하기 어려워 혼동을 야기할 수 있기 때문입니다.

```javascript
var coffee;
console.log(coffee); // undefined
```

### 5. null

null은 타 프로그래밍 언어와 동일하게 **값이 없다**는 것을 의미합니다. 어떠한 값도 없다는 것을 의미하기 때문에 undefined와 혼동이 될 수 있지만 null은 말 그대로 값이 아예 없어 텅텅 빈 상태라고 알면 조금 구분하기 쉽습니다.

```javascript
var nickname = "tigger";
console.log(nickname); // tigger;

nickname = null;
console.log(nickname) // null;
```

원래는 값이 있었지만 값을 없앨 때 null을 사용하여 메모리 공간을 컨트롤 하기도 합니다. 

### 6. symbol

symbol은 ES6에서 추가된 타입으로 다른 값과 중복되지 않는 유일한 값을 나타낼 때 사용합니다.

```javascript
var key = Symbol("key");
console.log(typeof key); // Symbol
```

### 7. 객체 타입

객체 타입은 아까 표에서 보았듯이 원시타입을 제외한 객체, 함수, 배열 등이 객체 타입으로 분류가 됩니다.  
현재 객체 타입은 알아보지 못했으니, 차후 객체 부분에서 추가로 다룰 예정입니다.  
간단하게 어떤 형태인지 알고만 넘어가겠습니다.

```javascript
var obj = {}; // object
var arr = []; // object
var func = function () {}; // function
```

## ❓ 왜 이런 데이터 타입이 필요한데요?

먼저 우리가 알고있는 개념을 다시 짚어보겠습니다.

우리는 변수가 선언되면 컴퓨터의 메모리에 변수명을 가지고 자리를 잡게 된다고 알고 있습니다. 그리고 필요시 식별자를 통해 해당 데이터를 가져오게 될 겁니다.

그런데 말입니다... 만약 데이터 타입이 없다면..? 어떻게 될지 생각해보겠습니다.  
값을 할당한 후 메모리에 저장을 할 때 공간을 얼마나 할당할 것이고, 무슨 값으로 저장할 것이며.. 이런 사항들을 하나도 고려하지 않게 되겠죠?  
👌 오케이 백번 양보해서!! 그렇게 저장까지는 했다고 칩시다.

그럼 이제 식별자를 통해 가져올 때 어떻게 가져와야할까요..?  
무엇이 들어가 있을지도 모르는 공간을 찾아내고, 얼마를 차지하고 있는지도 모르기 때문에 굉장히 방황할 것만 같은 느낌이 듭니다. \(실제로 내부에서는 어떻게 정확히 동작 하는지 추후 알아볼 예정입니다.\)  
  
뭔가 문제점이 있다는 것이 느껴지시나요?  
생각만 해도 벌벌 떨립니다..;;; 🥶

그렇다면 이제 데이터 타입이 있다고 가정해 봅시다.  
개발자가 숫자 타입으로 선언하여 메모리 공간에 자리 잡게 해주었습니다. 이 때 자리를 잡을 때 **숫자** 라는 타입이 있기 때문에 정해진 공간의 크기를 배정 받게 되고, 이 크기에 맞춰 메모리 공간에 자리를 잡게 될 것입니다.

그 다음 식별자를 통해 숫자를 가져오려고 할겁니다. 이전과 다르게 우리는 이미 숫자 타입을 통해 공간에 할당해 주었습니다. 그렇다면 가져올 때도 숫자 타입에 맞춘 공간을 정하고 탐색하면 방황하지 않고 바로 해당 데이터를 곧바로 가져올 수 있겠죠? 그리고 가져올 데이터를 읽어들일 때도 숫자 타입인 것을 알기 때문에 바로 해석이 가능할 것입니다.

이처럼 데이터 타입은 단순히 저 데이터가 어떠한 타입이구나! 를 식별하는 것 뿐만 아니라  
**메모리의 공간을 결정**하고, **메모리의 공간을 식별**하고, **어떻게 해석할지**를 결정하는 아주 중요한 역할을 수행합니다.

