---
description: 자바스크립트에서 객체를 다루기 위한 개념을 살펴보겠습니다.
---

# 함수

![](../.gitbook/assets/function.png)

## 🤔 함수란 무엇인가요?

자바스크립트에서의 함수는 객체와 더불어 가장 중요한 핵심 개념입니다. 객체와 더불어 모든 개념들이 이 함수와 깊은 연관성을 가지고 동작하기 때문에 어렵더라도 정확히 이해를 해야만 자바스크립트를 잘 이해할 수 있습니다.

자바스크립트의 함수는 어떠한 과정을 하나의 **단위**로 분리하여 정의한 것을 말합니다.  
위 설명만 들으면 잘 이해가 되지 않으시겠지만, 말 그대로 일련의 과정을 특정 단위로 분리 했다는 것이라고 보면 됩니다.

이제 실제 코드를 보면서 함수를 살펴보겠습니다.

## 🔍 함수는 어떻게 생겼나요?

함수는 기본적으로 총 3가지의 개념을 가지고 태어납니다.

* 함수 이름 \(function name\)
* 매개변수 \(parameter\)
* 반환값 \(return\)

위 세가지는 함수를 만들어내는 가장 기초적인 개념들입니다.  
먼저 생김새를 보고 하나씩 살펴보겠습니다.

```javascript
function add(x, y) {
    return x + y;
}

add(1, 2); // 함수 실행
```

위 코드는 3가지의 개념을 가지고 있는 가장 기본적인 함수입니다.  
function 다음에 있는 **add**는 **함수 이름**, 함수 이름 옆에 괄호로 표현된 **\(x, y\)**는 **매개변수**, 코드 블럭 안에 있는 return 에 표현되어 있는 **x + y**는 **반환값** 입니다.

그리고 이 세가지를 만들고 가만히 놔둔다면 함수를 만들기만 했을 뿐이지 실행하진 않은 것입니다.  
이를 실행하기 위해선 만들어낸 함수 이름과, 매개변수값을 넣은 다음 선언해주면 만든 함수를 호출하게 됩니다.

위에서 본 코드를 보면 대략 함수가 어떤 형태로 만들어지고, 어떻게 사용하는지 감이 오실 것입니다. 😮  
이 함수는 **함수 선언문**을 통해서 정의한 함수입니다. 이 말은 무엇을 뜻할까요? 바로 함수를 다르게 만들 수도 있다는 것입니다. 😱

한 번 알아보겠습니다.

## 🔨 함수를 정의하는 방법엔 어떤 것들이 있나요?

### 1. 함수 선언문

함수 선언문은 아까 위에서 함수를 정의 했던 방식입니다. 위에서 설명했던 3가지의 개념을 가지고 선언 하는 것이 함수 선언문의 방식입니다. ****

```javascript
function add(x, y) {
    return x + y;
}

add(1, 2); // 함수 실행
```

함수 선언문은 중요한 부분이 2가지가 있습니다.

1. **함수 이름**을 생략할 수 없습니다.
2. 표현식이 아닌 **문**입니다.

함수 선언문의 경우 함수의 이름이 **항상** 붙어다녀야합니다. 이유는 자바스크립트 엔진이 식별자 없이는 대상을 찾지 못하기 때문인데요, 함수 선언문의 **함수 이름**은 **함수 몸체 내부에서만 유효한 식별자**로 동작합니다.  
  
그 말은 즉❗️ 밖에서는 이 함수를 알 수 있는 **식별자가 없다**는 것입니다. 그렇다면 자바스크립트 엔진은 함수를 참조할 수 없기 때문에 호출을 할 수 없게 되겠죠..🥶

그래서 자바스크립트 엔진은 함수 선언문을 해석하여 함수 객체를 생성할 때, 정의된 **함수 선언문의 이름**과 **동일한 이름**의 식별자를 **암묵적으로 생성**하고 거기에 **함수 객체를 할당**하게 됩니다.

즉 함수를 호출할 때 함수 이름으로 호출하는 것이 아닌 **암묵적으로 만든 함수 객체**를 가리키는 **식별자로 호출**한다는 것입니다. 한 번 코드로 살펴보겠습니다

```javascript
var add = function add(x, y) {
    return x + y;
}

add(2, 5); // function add()가 아닌, var add 를 호출한 상태
```

함수 선언문의 이름과 같은 식별자를 통해 변수처럼 담은 것이 보이시나요?  
위 설명은 잘 이해가 가지 않지만, 실제 자바스크립트 엔진이 함수 선언문을 해석하고 실행하기 위해서 코드를 위와 같이 바꾼다고 생각하면 됩니다.

결론은, **자바스크립트 엔진에서 함수 선언문은 함수 선언문의 이름과 동일한 식별자를 만들어내서 식별하고 호출한다는 것입니다.**  
위 코드는 함수를 정의하는 또 하나의 방식인 **함수 표현식**과 동일하게 생겼는데요, **코드는 동일**하지만 **동일하게 동작하는 것은 아닙니다.**

한 번 살펴보겠습니다.

### 2. 함수 표현식

자바스크립트는 **일급 객체**의 특징을 가지고 있어서 값으로서 함수를 다룰 수 있습니다. 즉, 함수를 변수에 할당하여 활용이 가능하다는 것이죠

```javascript
var add = function (x, y) {
    return x + y;
}

add(2, 5); // 7
```

위에서 살펴본 선언문이 자바스크립트 엔진에 의해 식별자를 임의로 만들어낸 방식과 비슷하게 생겼죠?  
하지만 위에서 보는 코드와 다른점은 **함수에 이름이 없다**는 것입니다.  
이런 형태의 함수를 **익명 함수**라고 합니다.

그렇다고 해서 함수 표현식이 꼭 익명 함수로 표현되는 것은 아닙니다.

```javascript
var add = function sum (x, y) {
    return x + y;
}

add(2, 5); // 7
sum(2, 5); // ReferenceError: sum is not defined
```

위 처럼 함수에 이름을 붙여도 되는데요, 여기서 **주의할 점**은 자바스크립트 엔진은 함수 명이 아닌 **식별자**로 함수를 식별하기 때문에 함수명을 호출하게 되면 참조 에러가 등장 하게 되니 이점을 유의해야 합니다. 👌

### 3. 화살표 함수

화살표 함수는 ES6에서 도입된 방법입니다. 마치 화살표 모양과 같다고 해서 붙여진 이름인데요, function 키워드 대신 화살표를 사용해서 함수를 선언할 수 있습니다.  
주의할 점은 화살표 함수를 통해 함수를 선언할 시 익명 함수로 선언해야 합니다.

```javascript
var add = (x, y) => {
    return x + y;
}

add(2, 5); // 7
```

## 📞 함수 호이스팅\(Hoisting\)

함수 선언문과 표현식의 정말 큰 차이가 있는데 바로 **함수** **호이스팅\(Hoisting\)**이라는 개념입니다.  
추후에 따로 주제를 만들어 살펴볼 예정이지만 미리 살짝 알아보면,  
**함수의 생성 시점의 차이** 때문에 호출 가능 여부가 달라 지게 되는데요

```javascript
console.log(add); // f add(x, y)
console.log(sum); // undefined

add(2, 5) // 7
sum(5, 5) // ReferenceError: sum is not a function 

// 함수 선언문
function add(x, y) {
    return x + y;
}

// 함수 표현식
var sum = function (x, y) {
    return x + y;
}
```

위 예제를 보면 차이가 무엇인지 대략 눈치는 챌 수 있을 것입니다.  
**함수 선언문**은 선언 순서와 관계 없이 **언제든 호출**이 가능하고, **함수 표현식**은 **먼저** **호출을 못하는 것**인데요

이 이유는 **자바스크립트 엔진**에 있습니다. \(너무 자주 등장하는 복잡한 친구...🤪\)  
자바스크립트는 **인터프리터 언어**로서 위에서부터 차례대로 코드를 실행합니다\(런타임\).  
하지만 자바스크립트 엔진은 런타임 환경 이전에 먼저 준비하는 과정을 거치는데요

이 과정에서 선언문으로 선언한 모든 코드들이 먼저 자바스크립트 엔진에 의해 실행되게 되고, 런타임 환경 전에 함수 선언문은 자바스크립트 엔진이 만들어낸 가상 식별자까지 가지게 됩니다.  
즉, 이미 런타임 환경 전에 자바스크립트 엔진에 의해 **함수 선언문은 만들어져있는 상태**이기 때문에 언제 어디서든 함수 선언문으로 선언한 함수를 사용할 수 있게 됩니다.

마치 최상단으로 끌어올려진 것처럼 보이게 되는 현상을 바로 **함수** **호이스팅**이라고 하는 것입니다.

하지만 함수 표현식으로 만들어낸 함수는 함수 호이스팅이 아닌 **변수 호이스팅**으로 동작합니다.  
변수 호이스팅은 함수 호이스팅과는 다르게 변수가 할당되는 시점 즉, 런타임 환경에서 판별하게 되어 해당 변수에 함수가 할당되는 시점에 왔을 때 함수를 해당 변수로 인지하고 함수 객체가 되는 것입니다.

